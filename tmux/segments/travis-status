#!/usr/bin/env ruby
# encoding: UTF-8

# Travis Status Check
# (requires the `travis` gem and a Travis pro account)
# shows notifications via the `terminal-notifier` gem

require "travis/pro"
require 'terminal-notifier'

unless ENV['TRAVIS_TOKEN'] && ENV['TRAVIS_REPO'] && ENV['TRAVIS_BRANCH']
  puts "Failed: please ensure TRAVIS_TOKEN, TRAVIS_REPO and TRAVIS_BRANCH are set, e.g."
  puts "  gem install travis"
  puts "  travis login --pro"
  puts "  travis token --pro"
  exit 1
end

config = {
  tmp_file: '/var/tmp/tmux-travis-status',
  pid_file: '/var/tmp/tmux-travis.pid',
}

def find_repo(repo_name)
  Travis::Pro.access_token = ENV['TRAVIS_TOKEN']
  Travis::Pro::Repository.find(ENV['TRAVIS_REPO'])
end

def valid_build?(build)
  build.finished? &&
    (build.branch_info =~ /#{ENV['TRAVIS_BRANCH']}/) &&
    !build.errored? &&
    !build.pull_request?
end

def parse_build(build)
  if build.failed?
    minutes_ago = ((Time.now.utc - build.finished_at) / 60.0).floor
    {
        tmux: { bg: "160", fg: "000", label: "âœ˜ #{minutes_ago}m" },
      notify: { title: "ðŸ’” Travis Build Failed!", sound: "Basso" }
    }
  elsif build.passed?
    {
        tmux: { bg: "041", fg: "016", label: "âœ”ï¸Ž" },
      notify: { title: "ðŸ’š Travis Build Passed!", sound: "Tink" }
    }
  end
end

def update_status(build, config)
  if build_state = parse_build(build)

    # write tmux segment to tmp file
    output = "#[bg=colour000,fg=colour#{build_state[:tmux][:bg]}]â®‚#[bg=colour#{build_state[:tmux][:bg]},fg=colour#{build_state[:tmux][:fg]}] #{build_state[:tmux][:label]} #[fg=colour000,bg=colour#{build_state[:tmux][:bg]}]â®‚#[default]"
    File.open(config[:tmp_file], 'w') { |f| f.write(output) }

    # show terminal notification
    TerminalNotifier.notify(build.commit.message, build_state[:notify].merge({
      subtitle: "#{build.commit.committer_name} (#{(build.duration/60.0).floor} mins)",
          group: "travis-#{build.commit.branch}-build",
          open: build.commit.compare_url
    }))

    output
  end
end

def clean_exit(config)
  if File.exists?(config[:pid_file])
    File.delete(config[:pid_file])
  end
  exit
end

# read output from tmp file if present
if File.exists?(config[:tmp_file])
  puts File.read(config[:tmp_file])
else
  # otherwise (if no pid exists) find repo and listen for finished build events
  unless File.exists?(config[:pid_file])
    pid = fork do
      # clean pid file on quiting
      trap(:HUP)  { clean_exit(config) }
      trap(:TERM) { clean_exit(config) }
      trap(:KILL) { clean_exit(config) }

      # find repo
      repo = find_repo(ENV['TRAVIS_REPO'])

      # store (and show) initial build status if present
      if build = repo.builds.detect { |build| valid_build?(build) }
        puts update_status(build, config)
      end

      # listen and act on events
      Travis::Pro.listen(repo) do |stream|
        stream.on('build:finished') do |event|
          if valid_build?(event.build)
            update_status(event.build, config)
          end
        end
      end
    end

    # write pid to file
    File.open(config[:pid_file], 'w') { |f| f.write(pid) }
  end
end

#!/usr/bin/env ruby
# encoding: UTF-8

# Travis (Pro) Status Check
# Requires `travis` and `terminal-notifier` gems
#
# Get a Travis Pro token with;
#  gem install travis
#  travis login --pro
#  travis token --pro"

require "travis/pro"
require 'terminal-notifier'

unless ENV['TRAVIS_TOKEN'] && ENV['TRAVIS_REPO'] && ENV['TRAVIS_BRANCH']
  puts "Failed: please ensure TRAVIS_TOKEN, TRAVIS_REPO & TRAVIS_BRANCH are set"
  exit 1
end

@config = {
  tmp_file: '/var/tmp/tmux-travis-status',
  pid_file: '/var/tmp/tmux-travis.pid',
}

def find_repo(repo_name)
  Travis::Pro.access_token = ENV['TRAVIS_TOKEN']
  Travis::Pro::Repository.find(ENV['TRAVIS_REPO'])
end

def valid_build?(build)
  build.finished? &&
    !build.errored? &&
    !build.pull_request? &&
    (build.branch_info =~ /#{ENV['TRAVIS_BRANCH']}/)
end

def parse_build(build)
  if build.failed?
    minutes_ago = ((Time.now.utc - build.finished_at) / 60.0).floor
    {
      tmux: { bg: "160", fg: "000", label: "âœ˜ #{minutes_ago}m" },
      notify: { title: "ðŸ’” Travis Build Failed!", sound: "Basso" }
    }
  elsif build.passed?
    {
      tmux: { bg: "041", fg: "016", label: "âœ”ï¸Ž" },
      notify: { title: "ðŸ’š Travis Build Passed!", sound: "Tink" }
    }
  end
end

# update the travis status segment
def update_status(build)
  if build_state = parse_build(build)

    # write tmux segment to file
    output = "#[bg=colour000,fg=colour#{build_state[:tmux][:bg]}]â®‚#[bg=colour#{build_state[:tmux][:bg]},fg=colour#{build_state[:tmux][:fg]}] #{build_state[:tmux][:label]} #[fg=colour000,bg=colour#{build_state[:tmux][:bg]}]â®‚#[default]"
    File.open(@config[:tmp_file], 'w') { |f| f.write(output) }

    # show notification
    TerminalNotifier.notify(build.commit.message, build_state[:notify].merge({
      subtitle: "#{build.commit.committer_name} (#{(build.duration/60.0).floor} mins)",
      group: "travis-#{build.commit.branch}-build",
      open: build.commit.compare_url
    }))

    output
  end
end

# cleanly exit the forked process
def clean_exit
  if File.exists?(@config[:pid_file])
    File.delete(@config[:pid_file])
  end
  exit
end

# read output from tmp file if present
if File.exists?(@config[:tmp_file])
  puts File.read(@config[:tmp_file])
end

# if no pid exists, find repo and listen for finished build events
unless File.exists?(@config[:pid_file])
  pid = fork do
    # clean pid file on quiting
    trap(:HUP)  { clean_exit }
    trap(:TERM) { clean_exit }
    trap(:KILL) { clean_exit }

    # find repo
    repo = find_repo(ENV['TRAVIS_REPO'])

    # store (and show) initial build status if present
    if build = repo.builds.detect { |build| valid_build?(build) }
      puts update_status(build)
    end

    # listen and act on events
    Travis::Pro.listen(repo) do |stream|
      stream.on('build:finished') do |event|
        if valid_build?(event.build)
          update_status(event.build)
        end
      end
    end
  end

  # write pid to file
  File.open(@config[:pid_file], 'w') { |f| f.write(pid) }
end

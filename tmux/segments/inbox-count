#!/usr/bin/env ruby
# encoding: UTF-8

# IMAP Inbox Check
# Requires `terminal-notifier` gem and keychain entry for imap password

require 'net/imap'
require 'terminal-notifier'

@config = {
  username: 'matt@hiddenloop.com',
  server: 'imap.gmail.com',
  mailbox: 'INBOX',
  idle: 3, # minutes
  tmp_file: '/var/tmp/tmux-inbox-status',
  pid_file: '/var/tmp/tmux-inbox.pid',
}

# get password from the OSX keychain
def get_keychain_password(username, server)
  if result = `security 2>&1 > /dev/null find-internet-password -ga #{username} -s #{server}`
    result.match(/\"(\w+)\"/).to_a.last
  end
end

# imap connect and select mailbox
def connect_imap_mailbox
  imap = Net::IMAP.new('imap.gmail.com', 993, true)
  imap.login(@config[:username],
    get_keychain_password(@config[:username], @config[:server]))
  imap.select(@config[:mailbox])
  imap
end

# update unread message count segment
def update_count(count)
  if count > 0
    # write tmux segment to file
    output = "#[bg=colour000,fg=colour237]â®‚#[bg=colour237,fg=colour255] âœ‰ #[fg=colour190]#{count} #[fg=colour000,bg=colour237]â®‚#[default]"
    File.open(@config[:tmp_file], 'w') { |f| f.write(output) }

    # show notification
    TerminalNotifier.notify("#{count} new message#{count > 1 ? 's' : ''}",
      title: "ðŸ“¬ You've got Mail",
      subtitle: "#{@config[:username]}".downcase,
      group: "tmux-inbox-status",
      open: "https://mail.google.com",
      sound: "Tink"
    )
  end
end

# cleanly exit the forked process
def clean_exit
  if File.exists?(@config[:pid_file])
    File.delete(@config[:pid_file])
  end
  exit
end

# read output from tmp file if present
if File.exists?(@config[:tmp_file])
  puts File.read(@config[:tmp_file])
end

# if no pid exists, fork a process to listen during imap idles
unless File.exists?(@config[:pid_file])
  pid = fork do
    # clean pid file on quiting
    trap(:HUP)  { clean_exit }
    trap(:TERM) { clean_exit }
    trap(:KILL) { clean_exit }

    # initial mailbox check
    imap = connect_imap_mailbox
    imap.examine(@config[:mailbox])
    update_count(imap.search(["NOT", "SEEN"]).length)

    # setup a response handler
    imap.add_response_handler do |resp|
      if resp.kind_of?(Net::IMAP::UntaggedResponse) && resp.name == 'EXISTS'
        update_count(resp.data.to_i)
      end
    end

    begin
      # start idle loop
      loop do
        imap.idle do
          # wait before renewing idle
          sleep @config[:idle] * 60
          imap.idle_done
        end
      end
    rescue Errno::ECONNRESET
      puts "Connection reset by peer"
    rescue Net::IMAP::Error => e
      puts "Imap error : #{e.inspect}"
    ensure
      # exit all threads
      Thread.list.each {|thr| thr.exit }
      # end imap idling and logout
      imap.idle_done
      imap.logout
      clean_exit
    end
  end

  # write pid to file
  File.open(@config[:pid_file], 'w') { |f| f.write(pid) }
end

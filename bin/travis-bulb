#!/usr/bin/env ruby
# encoding: UTF-8

# Travis (Pro) status check with bulb indication
# Requires `travis`, `hue` and `lifx` gems
#
# Get a Travis Pro token with;
#  gem install travis
#  travis login --pro
#  travis token --pro"

require "travis/pro"
require 'hue'
require 'lifx'

unless ENV['TRAVIS_TOKEN'] && ENV['TRAVIS_REPO'] && ENV['TRAVIS_BRANCH'] &&
    (ENV['TRAVIS_LIFX_BULB'] || ENV['TRAVIS_HUE_BULB'])
  puts "Failed: please ensure TRAVIS_TOKEN, TRAVIS_REPO, TRAVIS_BRANCH & TRAVIS_(HUE/LIFX)_BULB are set"
  exit 1
end

@config = {
  pid_file: '/var/tmp/travis-bulb.pid',
  log_file: '/var/log/travis-bulb.log',
  interval: 300, # seconds (5 mins)
  lifx: ENV['TRAVIS_LIFX_BULB'],
  hue: ENV['TRAVIS_HUE_BULB']
}

@logger = Logger.new(@config[:log_file])
@logger.progname = 'travis-bulb'

def log(message, level = :info)
  @logger.send(level, message)
end

def find_repo(repo_name)
  Travis::Pro.access_token = ENV['TRAVIS_TOKEN']
  Travis::Pro::Repository.find(ENV['TRAVIS_REPO'])
end

def valid_build?(build)
  build.finished? &&
    !build.errored? &&
    !build.pull_request? &&
    (build.branch_info =~ /#{ENV['TRAVIS_BRANCH']}/)
end

def update_hue(hue)
  light = Hue::Client.new.lights.select { |l| l.name == @config[:hue] }.first

  if light
    # turn light on and set color
    log("updating HUE bulb with name '#{@config[:hue]}'")
    light.on = true
    light.saturation = 255
    light.brightness = 140
    light.hue = hue
    light.refresh
  end
end

def update_lifx(color)
  client = LIFX::Client.lan
  light  = nil
  client.discover! do |c|
    light = c.lights.with_label(@config[:lifx])
  end

  if light
    log "updating LIFX bulb with label '#{@config[:lifx]}'"
    # turn light on and set color
    if light.off?
      light.turn_on
    end
    if light.color != color
      light.set_color(color, duration: 5)
      client.flush
    end
  end
end

# update the bulb to show status
def update_bulb(build)
  if build.failed?
    if @config[:lifx]
      update_lifx(LIFX::Color.red)
    elsif @config[:hue]
      update_hue(0)
    end
  elsif build.passed?
    if @config[:lifx]
      update_lifx(LIFX::Color.green)
    elsif @config[:hue]
      update_hue(25500)
    end
  end
end

# cleanly exit the forked process
def clean_exit
  if File.exists?(@config[:pid_file])
    File.delete(@config[:pid_file])
  end
  exit
end

# check status and update bulb
def fetch_and_update(repo)
  log "looking for a valid build on '#{ENV['TRAVIS_BRANCH']}' branch"
  if build = repo.builds.detect { |build| valid_build?(build) }
    log "found a valid build!"
    update_bulb(build)
  end
end

# if no pid exists, find repo and listen for finished build events
if File.exists?(@config[:pid_file])
  log "PID file #{@config[:pid_file]} already exists, quiting", :warn
else
  pid = fork do
    # clean pid file on quiting
    trap(:HUP)  { clean_exit }
    trap(:TERM) { clean_exit }
    trap(:KILL) { clean_exit }

    # find repo
    repo = find_repo(ENV['TRAVIS_REPO'])

    if repo
      log "found repo '#{ENV['TRAVIS_REPO']}'"

      # start a thread loop to periodically check builds
      Thread.new do
        while true do
          fetch_and_update(repo)
          log "sleeping for #{@config[:interval]} seconds"
          sleep @config[:interval]
        end
      end

      # listen and act on events
      Travis::Pro.listen(repo) do |stream|
        stream.on('build:finished') do |event|
          log "recieved 'build:finished' event on stream"
          if valid_build?(event.build)
            update_bulb(event.build)
          end
        end
      end

    end
  end

  # write pid to file
  log "writing to PID file #{@config[:pid_file]}"
  File.open(@config[:pid_file], 'w') { |f| f.write(pid) }
end

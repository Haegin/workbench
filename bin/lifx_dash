#!/usr/bin/env ruby

# install gem dependencies with:
#   gem install packetfu --no-ri --no-rdoc
# find dash mac address with:
#   lifx_dash snoop
# grab a lifx token from:
#   https://cloud.lifx.com/settings

require "packetfu"
require "net/https"

module LifxDash
  class Toggle

    def initialize(token, selector = "all")
      @token    = token
      @selector = selector
    end

    def toggle
      log "[POST] #{uri}"
      log @token

      Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
        req = Net::HTTP::Post.new(uri)
        req.add_field "Authorization", "Bearer #{@token}"
        res = http.request(req)

        log "API reply (#{res.code}): #{res.body}"
      end
    end

    private

    def log(message)
      puts "#{Time.now} - #{self.class} - #{message}"
    end

    def uri
      @uri ||= URI("https://api.lifx.com/v1/lights/#{@selector}/toggle")
    end
  end


  class Monitor

    def initialize(mac_address = nil, iface = "en0")
      @mac_address = mac_address
      @iface = iface
    end

    def listen(&block)
      # listen to (and parse) packets
      capture.stream.each do |packet|
        pkt = PacketFu::ARPPacket.parse(packet)
        mac = PacketFu::EthHeader.str2mac(pkt.eth_src)

        # check mac address matches and arp opcode is 1
        if (mac == @mac_address) || @mac_address.nil?
          if pkt.arp_opcode == 1
            log pkt.peek
            block.call(pkt, mac) if block
          end
        end
      end
    end


    private

    def log(message)
      puts "#{Time.now} - #{self.class} - #{message}"
    end

    def capture
      # sniff and filter for ARP packets on the interface
      @capture ||= PacketFu::Capture.new(
        :iface => @iface,
        :start => true,
        :filter => "arp"
      )
    end
  end

  # set up monitor and toggle, then listen for packets
  def self.run(opts = {})
    monitor = LifxDash::Monitor.new(opts[:dash_mac_address], opts[:iface])
    lifx = LifxDash::Toggle.new(opts[:lifx_token], opts[:lifx_selector])
    monitor.listen { |pkt| lifx.toggle }
  end

  # just listen for any dash like arp packets, from any device
  def self.snoop(iface)
    puts "NOTE: listening for dash packets, you may get more than 1 from a press"
    puts "if so, look for the mac address that occurs only once"
    puts "wait for the network to quiet down, before pressing the button"
    puts "now snooping on network interface: #{iface} ...\n\n"
    LifxDash::Monitor.new(nil, iface).listen
  end

  def self.help
    puts "usage: "
    puts "  lifx_dash mac_address lifx_token {lifx_selector:all} {network_iface:en0}"
    puts "  lifx_dash snoop {network_iface:en0}"
    exit 1
  end
end

# check args
if ARGV[0] == 'snoop'
  LifxDash.snoop(ARGV[1] || "en0")
elsif ARGV.length > 1
  LifxDash.run(
    dash_mac_address: ARGV[0],
          lifx_token: ARGV[1],
       lifx_selector: ARGV[2] || "all",
               iface: ARGV[3] || "en0"
  )
else
  LifxDash.help
end

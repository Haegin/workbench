#!/usr/bin/env ruby

# Thanks to @edwardbenson for the idea:
#   http://tinyurl.com/zujfkjs
#
# TODO:
#   * better argument handling
#   * better at_exit handling
#   * better HTTP API error handling
#   * helpful error messages
#   * configure command / file
#   * gem
#   * tests
#   * construct packets for Lifx LAN API

# install gem dependencies with:
#   gem install packetfu --no-ri --no-rdoc
# find dash mac address with:
#   lifx_dash snoop
# grab a lifx token from:
#   https://cloud.lifx.com/settings

require "packetfu"
require "net/https"
require "logger"

module LifxDash
  class Toggle

    attr_reader :logger

    def initialize(token, selector = "all", logger)
      @token    = token
      @selector = selector
      @logger   = logger
    end

    def toggle
      logger.info "API (POST) request: #{uri}"

      Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
        req = Net::HTTP::Post.new(uri)
        req.add_field "Authorization", "Bearer #{@token}"
        res = http.request(req)
        logger.info"API reply (#{res.code}): #{res.body}"
      end
    rescue URI::InvalidURIError => e
      raise e
    end

    private

    def uri
      @uri ||= URI("https://api.lifx.com/v1/lights/#{@selector}/toggle")
    end
  end


  class Monitor

    attr_reader :iface

    def initialize(mac_address = nil, iface = "en0")
      @mac_address = mac_address
      @iface = iface
    end

    def listen(&block)
      # listen to (and parse) packets
      capturer.stream.each do |packet|
        pkt = PacketFu::ARPPacket.parse(packet)
        mac = PacketFu::EthHeader.str2mac(pkt.eth_src)

        # check mac address matches and arp opcode is 1
        if (mac == @mac_address) || @mac_address.nil?
          if pkt.arp_opcode == 1
            block.call(pkt, mac) if block
          end
        end
      end
    end


    private

    def capturer
      # sniff and filter for ARP packets on the interface
      @capturer ||= PacketFu::Capture.new(
        iface: @iface,
        start: true,
        filter: "arp"
      )
    end
  end

  LOG_PATH = "/var/log/lifx_dash.log"

  # lifx_dash command entry methods
  # set up monitor and toggle, then listen for packets
  def self.run(opts = {})
    logger  = Logger.new(LOG_PATH)
    monitor = LifxDash::Monitor.new(opts[:dash_mac_address], opts[:iface])
    lifx    = LifxDash::Toggle.new(opts[:lifx_token], opts[:lifx_selector], logger)

    puts "[#{Process.pid}] starting lifx dash button monitor ... (logging to #{LifxDash::LOG_PATH})"
    logger.info "Started listening for ARP packets on #{monitor.iface}"
    monitor.listen do |pkt, mac|
      logger.debug pkt.peek
      lifx.toggle
    end
  end

  # just listen for any dash like arp packets, from any device
  def self.snoop(iface)
    puts "listening for dash button packets on #{iface} ... [CTRL-c] to stop"
    puts "wait for the network to quiet down, before pressing the button"
    puts "you may get more than 1 from a press, so look for the mac address that occurs only once."

    LifxDash::Monitor.new(nil, iface).listen do |pkt, mac|
      puts "packet from (#{mac}) - #{pkt.peek}"
    end
  end

  # show command help information
  def self.help
    puts "usage: "
    puts "  lifx_dash monitor mac_address lifx_token {lifx_selector} {network_iface}"
    puts "  lifx_dash snoop {network_iface}"
    exit
  end
end


## commands are;
# help
# version
# snoop {iface}
# monitor {mac} {lifx_token} {selector (name or id)} {iface} -d[aemonise]
# list lights
# config?

# check args and launch commands
if ARGV[0] == 'snoop'
  LifxDash.snoop(ARGV[1] || "en0")
elsif ARGV[0] == 'monitor' && ARGV.length > 2
  # daemonize
  Process.daemon

  LifxDash.run(
    dash_mac_address: ARGV[1],
          lifx_token: ARGV[2],
       lifx_selector: ARGV[3] || "all",
               iface: ARGV[4] || "en0"
 )
else
  LifxDash.help
end
